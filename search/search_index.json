{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"AFX Concepts # AFX is a command-line package manager. afx can allow us to manage almost all things available on GitHub, Gist and so on. Before, we needed to trawl web pages to download each package one by one. It's very annoying every time we set up new machine and also it's difficult to get how many commands/plugins we installed. So afx's motivation is coming from that and to manage them with YAML files (as a code). $ afx help Package manager for CLI Usage: afx [flags] afx [command] Available Commands: check Check new updates on each package completion Generate completion script help Help about any command init Initialize installed packages install Resume installation from paused part (idempotency) self-update Update afx itself to latest version show Show packages managed by afx uninstall Uninstall installed packages update Update installed package if version etc is changed Flags: -h, --help help for afx -v, --version version for afx Use \"afx [command] --help\" for more information about a command.","title":"Home"},{"location":"#afx-concepts","text":"AFX is a command-line package manager. afx can allow us to manage almost all things available on GitHub, Gist and so on. Before, we needed to trawl web pages to download each package one by one. It's very annoying every time we set up new machine and also it's difficult to get how many commands/plugins we installed. So afx's motivation is coming from that and to manage them with YAML files (as a code). $ afx help Package manager for CLI Usage: afx [flags] afx [command] Available Commands: check Check new updates on each package completion Generate completion script help Help about any command init Initialize installed packages install Resume installation from paused part (idempotency) self-update Update afx itself to latest version show Show packages managed by afx uninstall Uninstall installed packages update Update installed package if version etc is changed Flags: -h, --help help for afx -v, --version version for afx Use \"afx [command] --help\" for more information about a command.","title":"AFX Concepts"},{"location":"getting-started/","text":"Getting Started # Install the pre-compiled binary # You can install the pre-compiled binary (in several different ways), compile from source. Below you can find the steps for each of them. go install # $ go install github.com/b4b4r07/afx@latest manually # Download the pre-compiled binaries from the OSS releases page and copy them to the desired location. Write YAML # Let's say you want to install jq and enhancd with afx. So please write YAML file like this: github : - name : stedolan/jq description : Command-line JSON processor owner : stedolan repo : jq release : name : jq tag : jq-1.6 command : link : - from : '*jq*' to : jq - name : b4b4r07/enhancd description : A next-generation cd command with your interactive filter owner : b4b4r07 repo : enhancd plugin : env : ENHANCD_FILTER : fzf --height 25% --reverse --ansi:fzy sources : - init.sh This declaration means afx gets jq v1.6 from GitHub release and install it into PATH as a command. Okay, then let's save this file in ~/.config/afx/main.yaml . Install packages # After preparing YAML files, you become able to run install command: $ afx install This command runs install based on what were declared in YAML files. Initialize packages # After installed, you need to run this command to enable commands/plugins you installed. $ source < ( afx init ) afx init is just showing what needed to run commands/plugins. As a test, try to run. $ afx init source /Users/babarot/.afx/github.com/b4b4r07/enhancd/init.sh export ENHANCD_FILTER = \"fzf --height 25% --reverse --ansi:fzy\" As long as you don't run it with source command, it doesn't effect your current shell. Initialize when starting shell # Add this command to your shell config (e.g. .zshrc) enable plugins and commands you installed when starting shell. # enable packages source < ( afx init ) Update packages # If you want to update package to new version etc, all you have to do is just to modify YAML file and then run afx update : github: - name: stedolan/jq description: Command-line JSON processor owner: stedolan repo: jq release: name: jq - tag: jq-1.5 + tag: jq-1.6 command: link: - from: '*jq*' to: jq $ afx update \u2714 stedolan/jq Configure shell completions # You can also use shell completion with afx. To enable completion at starting a shell, you need to add below to your each shell \"rc\" files. Bash Zsh Fish $ source < ( afx completion bash ) $ source < ( afx completion zsh ) $ afx completion fish | source","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"getting-started/#install-the-pre-compiled-binary","text":"You can install the pre-compiled binary (in several different ways), compile from source. Below you can find the steps for each of them.","title":"Install the pre-compiled binary"},{"location":"getting-started/#go-install","text":"$ go install github.com/b4b4r07/afx@latest","title":"go install"},{"location":"getting-started/#manually","text":"Download the pre-compiled binaries from the OSS releases page and copy them to the desired location.","title":"manually"},{"location":"getting-started/#write-yaml","text":"Let's say you want to install jq and enhancd with afx. So please write YAML file like this: github : - name : stedolan/jq description : Command-line JSON processor owner : stedolan repo : jq release : name : jq tag : jq-1.6 command : link : - from : '*jq*' to : jq - name : b4b4r07/enhancd description : A next-generation cd command with your interactive filter owner : b4b4r07 repo : enhancd plugin : env : ENHANCD_FILTER : fzf --height 25% --reverse --ansi:fzy sources : - init.sh This declaration means afx gets jq v1.6 from GitHub release and install it into PATH as a command. Okay, then let's save this file in ~/.config/afx/main.yaml .","title":"Write YAML"},{"location":"getting-started/#install-packages","text":"After preparing YAML files, you become able to run install command: $ afx install This command runs install based on what were declared in YAML files.","title":"Install packages"},{"location":"getting-started/#initialize-packages","text":"After installed, you need to run this command to enable commands/plugins you installed. $ source < ( afx init ) afx init is just showing what needed to run commands/plugins. As a test, try to run. $ afx init source /Users/babarot/.afx/github.com/b4b4r07/enhancd/init.sh export ENHANCD_FILTER = \"fzf --height 25% --reverse --ansi:fzy\" As long as you don't run it with source command, it doesn't effect your current shell.","title":"Initialize packages"},{"location":"getting-started/#initialize-when-starting-shell","text":"Add this command to your shell config (e.g. .zshrc) enable plugins and commands you installed when starting shell. # enable packages source < ( afx init )","title":"Initialize when starting shell"},{"location":"getting-started/#update-packages","text":"If you want to update package to new version etc, all you have to do is just to modify YAML file and then run afx update : github: - name: stedolan/jq description: Command-line JSON processor owner: stedolan repo: jq release: name: jq - tag: jq-1.5 + tag: jq-1.6 command: link: - from: '*jq*' to: jq $ afx update \u2714 stedolan/jq","title":"Update packages"},{"location":"getting-started/#configure-shell-completions","text":"You can also use shell completion with afx. To enable completion at starting a shell, you need to add below to your each shell \"rc\" files. Bash Zsh Fish $ source < ( afx completion bash ) $ source < ( afx completion zsh ) $ afx completion fish | source","title":"Configure shell completions"},{"location":"how-it-works/","text":"How it works # Where to put YAML # Example of config directory structure. In afx, all installation declaration can be kept in YAML files. All configurations should be basically saved in $AFX_CONFIG_PATH . It defaults to ~/.config/afx . You can create YAML files that your package declarations are described and save them in this config directory. In AFX_CONFIG_PATH, you can keep files with these rules: Naming files as you like is ok Having single file can be ok Deviding into multiple files is also ok Creating sub dir can be also ok Let's describe each one below. Single file # You can create files with any name you like. In above case, declaration of GitHub packages are saved in github.yaml and packages of GitHub Releases are saved in release.yaml . Others (e.g. local etc) are saved in main.yaml . ~/.config/afx \u2514\u2500\u2500 afx.yaml It's ok to keep them in one single file. You can choose which one to suit your style. Multiple files # You can divide them into each files to make file name and its contents clear and also put it into one YAML file. ~/.config/afx \u251c\u2500\u2500 github.yaml \u251c\u2500\u2500 main.yaml \u2514\u2500\u2500 release.yaml Sub directories # Keeping files in sub directories is also ok. afx tries to walk all directories and find files ending with .yaml or .yml . ~/.config/afx \u251c\u2500\u2500 subdir \u2502 \u251c\u2500\u2500 github-1.yaml \u2502 \u2514\u2500\u2500 github-2.yaml \u251c\u2500\u2500 local.yaml \u2514\u2500\u2500 http.yaml State feature # afx have a state feature like Terraform . In afx, due to this state feature, what was written in the YAML files means always packages list of what a user desired to install. In short, adding a package declaration to YAML files is to install them to your system and also deleting a package declaration from YAML files is to uninstall from your system. State in afx All of package declarations are saved in the state file. Install and uninstall will be run by using the difference between YAML files and records in the state file Install Uninstall github: - name: b4b4r07/enhancd description: A next-generation cd command with your interactive filter owner: b4b4r07 repo: enhancd plugin: env: ENHANCD_FILTER: fzf --height 25% --reverse --ansi:fzy sources: - init.sh + - name: jhawthorn/fzy + description: A better fuzzy finder + owner: jhawthorn + repo: fzy + command: + build: + steps: + - make + - sudo make install After adding package declaration to your YAML, then run this command: $ afx install github: - name: b4b4r07/enhancd description: A next-generation cd command with your interactive filter owner: b4b4r07 repo: enhancd plugin: env: ENHANCD_FILTER: fzf --height 25% --reverse --ansi:fzy sources: - init.sh - - name: jhawthorn/fzy - description: A better fuzzy finder - owner: jhawthorn - repo: fzy - command: - build: - steps: - - make - - sudo make install After deleting package declaration from your YAML, then run this command: $ afx uninstall Localtion of a state file Location of state file defaults to ~/.afx/state.json . Currently afx does not provide the way to change this path and basically user should not touch this file because it's used internally by afx to keep equivalence between YAML files and its state file. It's likely to be happened unexpected install/uninstall by changing a state file. Workflow to install packages. The packages which need to be installed will be calculated from the state file. Then afx installs packages based on the demand of package declarations. Initialize your commands/plugins # After installed, basically you need to run afx init command and run source command with the output of that command in order to become able to use commands and plugins you installed. $ source < ( afx init ) This is just an example of afx init . Running source command with this output means these statements are evaluate in current shell. So we can use plugins in current shell and also aliases, variables and so on. $ afx init source /Users/babarot/.afx/github.com/b4b4r07/enhancd/init.sh export ENHANCD_FILTER = \"fzf --height 25% --reverse --ansi:fzy\" source /Users/babarot/.afx/github.com/zdharma-continuum/history-search-multi-word/history-search-multi-word.plugin.zsh source /Users/babarot/.afx/github.com/b4b4r07/zsh-vimode-visual/zsh-vimode-visual.zsh alias diff = \"colordiff -u\" source /Users/babarot/.afx/github.com/zdharma-continuum/fast-syntax-highlighting/fast-syntax-highlighting.plugin.zsh source /Users/babarot/.afx/github.com/b4b4r07/zsh-prompt-minimal/minimal.zsh-theme export PROMPT_PATH_STYLE = \"minimal\" export PROMPT_USE_VIM_MODE = \"true\" ## package shlide is not installed, so skip to init source /Users/babarot/.zsh/10_utils.zsh source /Users/babarot/.zsh/20_keybinds.zsh source /Users/babarot/.zsh/30_aliases.zsh source /Users/babarot/.zsh/50_setopt.zsh source /Users/babarot/.zsh/70_misc.zsh afx initialize step just only generates these statements based on your YAML files.","title":"How it works"},{"location":"how-it-works/#how-it-works","text":"","title":"How it works"},{"location":"how-it-works/#where-to-put-yaml","text":"Example of config directory structure. In afx, all installation declaration can be kept in YAML files. All configurations should be basically saved in $AFX_CONFIG_PATH . It defaults to ~/.config/afx . You can create YAML files that your package declarations are described and save them in this config directory. In AFX_CONFIG_PATH, you can keep files with these rules: Naming files as you like is ok Having single file can be ok Deviding into multiple files is also ok Creating sub dir can be also ok Let's describe each one below.","title":"Where to put YAML"},{"location":"how-it-works/#single-file","text":"You can create files with any name you like. In above case, declaration of GitHub packages are saved in github.yaml and packages of GitHub Releases are saved in release.yaml . Others (e.g. local etc) are saved in main.yaml . ~/.config/afx \u2514\u2500\u2500 afx.yaml It's ok to keep them in one single file. You can choose which one to suit your style.","title":"Single file"},{"location":"how-it-works/#multiple-files","text":"You can divide them into each files to make file name and its contents clear and also put it into one YAML file. ~/.config/afx \u251c\u2500\u2500 github.yaml \u251c\u2500\u2500 main.yaml \u2514\u2500\u2500 release.yaml","title":"Multiple files"},{"location":"how-it-works/#sub-directories","text":"Keeping files in sub directories is also ok. afx tries to walk all directories and find files ending with .yaml or .yml . ~/.config/afx \u251c\u2500\u2500 subdir \u2502 \u251c\u2500\u2500 github-1.yaml \u2502 \u2514\u2500\u2500 github-2.yaml \u251c\u2500\u2500 local.yaml \u2514\u2500\u2500 http.yaml","title":"Sub directories"},{"location":"how-it-works/#state-feature","text":"afx have a state feature like Terraform . In afx, due to this state feature, what was written in the YAML files means always packages list of what a user desired to install. In short, adding a package declaration to YAML files is to install them to your system and also deleting a package declaration from YAML files is to uninstall from your system. State in afx All of package declarations are saved in the state file. Install and uninstall will be run by using the difference between YAML files and records in the state file Install Uninstall github: - name: b4b4r07/enhancd description: A next-generation cd command with your interactive filter owner: b4b4r07 repo: enhancd plugin: env: ENHANCD_FILTER: fzf --height 25% --reverse --ansi:fzy sources: - init.sh + - name: jhawthorn/fzy + description: A better fuzzy finder + owner: jhawthorn + repo: fzy + command: + build: + steps: + - make + - sudo make install After adding package declaration to your YAML, then run this command: $ afx install github: - name: b4b4r07/enhancd description: A next-generation cd command with your interactive filter owner: b4b4r07 repo: enhancd plugin: env: ENHANCD_FILTER: fzf --height 25% --reverse --ansi:fzy sources: - init.sh - - name: jhawthorn/fzy - description: A better fuzzy finder - owner: jhawthorn - repo: fzy - command: - build: - steps: - - make - - sudo make install After deleting package declaration from your YAML, then run this command: $ afx uninstall Localtion of a state file Location of state file defaults to ~/.afx/state.json . Currently afx does not provide the way to change this path and basically user should not touch this file because it's used internally by afx to keep equivalence between YAML files and its state file. It's likely to be happened unexpected install/uninstall by changing a state file. Workflow to install packages. The packages which need to be installed will be calculated from the state file. Then afx installs packages based on the demand of package declarations.","title":"State feature"},{"location":"how-it-works/#initialize-your-commandsplugins","text":"After installed, basically you need to run afx init command and run source command with the output of that command in order to become able to use commands and plugins you installed. $ source < ( afx init ) This is just an example of afx init . Running source command with this output means these statements are evaluate in current shell. So we can use plugins in current shell and also aliases, variables and so on. $ afx init source /Users/babarot/.afx/github.com/b4b4r07/enhancd/init.sh export ENHANCD_FILTER = \"fzf --height 25% --reverse --ansi:fzy\" source /Users/babarot/.afx/github.com/zdharma-continuum/history-search-multi-word/history-search-multi-word.plugin.zsh source /Users/babarot/.afx/github.com/b4b4r07/zsh-vimode-visual/zsh-vimode-visual.zsh alias diff = \"colordiff -u\" source /Users/babarot/.afx/github.com/zdharma-continuum/fast-syntax-highlighting/fast-syntax-highlighting.plugin.zsh source /Users/babarot/.afx/github.com/b4b4r07/zsh-prompt-minimal/minimal.zsh-theme export PROMPT_PATH_STYLE = \"minimal\" export PROMPT_USE_VIM_MODE = \"true\" ## package shlide is not installed, so skip to init source /Users/babarot/.zsh/10_utils.zsh source /Users/babarot/.zsh/20_keybinds.zsh source /Users/babarot/.zsh/30_aliases.zsh source /Users/babarot/.zsh/50_setopt.zsh source /Users/babarot/.zsh/70_misc.zsh afx initialize step just only generates these statements based on your YAML files.","title":"Initialize your commands/plugins"},{"location":"links/","text":"Links # Examples on afx config: b4b4r07/dotfiles Similar projects: zplug/zplug","title":"Links"},{"location":"links/#links","text":"Examples on afx config: b4b4r07/dotfiles Similar projects: zplug/zplug","title":"Links"},{"location":"configuration/command/","text":"Command # afx's goal is to finally support to install packages as command , plugin or both. In afx, several pacakge types (e.g. github ) are supported but you can specify command and plugin field in all of sources. Parameters # link.from # Type Default string (required) link.from can be specified where to install from. Case 1 Case 2 Just install from current directory github : - name : so-fancy/diff-so-fancy description : Good-lookin' diffs. Actually\u2026 nah\u2026 The best-lookin' diffs. owner : so-fancy repo : diff-so-fancy command : link : - from : diff-so-fancy To specify where to install from, just need to fill in link.from . Case of including version string etc in file name github : - name : stedolan/jq description : Command-line JSON processor owner : stedolan repo : jq release : name : jq tag : jq-1.6 command : link : - from : '*jq*' to : jq This link.from field is based on downloaded package directory. If the binary name has unneeded string and it's difficult to find a binary with fixed string. In that case, you can use wildcard in from field. link.to # Type Default string $AFX_COMMAND_PATH/(command-name) link.to can be specified where to install to. If omitted, the command will be installed to $AFX_COMMAND_PATH . Case 1 Case 2 Case 3 Simple case, with renaming by using `to` field github : - name : mutantcornholio/prok description : easy process grep with ps output owner : mutantcornholio repo : prok command : link : - from : prok.sh to : prok By filling in link.to field, you can specify where to install to. This field can be omitted but in that case it will be regarded as same thing of link.from value. In short, you don't need to fill in this field if you don't need to rename link.from to new one while linking. If you want to rename command name from link.from to new one, you can use this field like above example (this prok.sh will be renamed to prok and then install it into PATH) from current working dir to external dir of afx github : - name : tmux-plugins/tpm description : Tmux Plugin Manager owner : tmux-plugins repo : tpm command : link : - from : . to : $HOME/.tmux/plugins/tpm This example shows you to link all contents in current working directory to ~/.tmux/plugins/tpm directory. You can use outside directory of afx in link.to field, but in that case you need to specify full path. Using tilda ~ is also ok to specify $HOME . Several links github : - name : ahmetb/kubectx description : Switch faster between clusters and namespaces in kubectl owner : ahmetb repo : kubectx command : link : - from : kubectx to : kubectl-ctx - from : kubens to : kubectl-ns link section is a list, so you can specify several pairs of from and to . env # Type Default map {} env allows you to set environment variables. By having this section in same YAML file of package declaration, you can manage it with same file. When we don't have afx, we should have environment variables in shell config (e.g. zshrc) even if not installed it yet or failed to install it. But thanks to afx, afx users can keep it with same files and enable it only while a package is installed. Needs to login new shell To enable environment variables to your shell, you need to run this command or start new shell after adding this command to your shel config (e.g. .zshrc): source < ( afx init ) Case 1 github : - name : sharkdp/bat description : A cat(1) clone with wings. owner : sharkdp repo : bat release : name : bat tag : v0.11.0 command : alias : bat-theme : bat --list-themes | fzf --preview='bat --theme={} --color=always ~/.zshrc' env : BAT_PAGER : less -RF BAT_STYLE : numbers,changes BAT_THEME : ansi-dark link : - from : '**/bat' alias # Type Default map {} alias allows you to set command aliases. Case 1 Case 2 Case 3 github : - name : daveewart/colordiff description : Primary development for colordiff owner : daveewart repo : colordiff command : alias : diff : colordiff -u link : - from : colordiff.pl to : colordiff github : - name : ogham/exa description : A modern version of 'ls'. owner : ogham repo : exa release : name : exa tag : v0.9.0 command : alias : l : exa --group-directories-first -T --git-ignore --level 2 la : exa --group-directories-first -a --header --git ll : exa --group-directories-first -l --header --git lla : exa --group-directories-first -la --header --git ls : exa --group-directories-first link : - from : '*exa*' to : exa github : - name : sharkdp/bat description : A cat(1) clone with wings. owner : sharkdp repo : bat release : name : bat tag : v0.11.0 command : alias : bat-theme : bat --list-themes | fzf --preview='bat --theme={} --color=always ~/.zshrc' env : BAT_PAGER : less -RF BAT_STYLE : numbers,changes BAT_THEME : ansi-dark link : - from : '**/bat' build.steps # Type Default list [] build.steps can be specified build commands to build a package. Case 1 Case 2 Using sudo github : - name : jhawthorn/fzy description : A better fuzzy finder owner : jhawthorn repo : fzy command : build : steps : - make - sudo make install In this case, build steps has sudo command but it can be run as expected. But in advance you will be asked to input sudo password. Using go build github : - name : iovisor/kubectl-trace description : Schedule bpftrace programs on your kubernetes cluster using the kubectl owner : iovisor repo : kubectl-trace command : build : steps : - go build -o kubectl-trace cmd/kubectl-trace/root.go link : - from : kubectl-trace to : kubectl-trace In this case, build steps run go build command because this package does not provide GitHub releases on its own page. So we need to build by ourselves. afx build feature is very helpful in such a case. go build command creates red command to current working directory so you need to have link section to install the built binary to your PATH. build.env # Type Required map {} build.env can be specified environemnt variables used when running build a package. Case 1 github : - name : jhawthorn/fzy description : A better fuzzy finder owner : jhawthorn repo : fzy command : build : steps : - make - sudo make install env : VERSION : 1.0 In this case, VERSION is specified to change version used in build steps. snippet # Type Required string \"\" snippet allows you to specify the command which are runned when starting new shell. Case 1 Login message if tpm is installed github : - name : tmux-plugins/tpm description : Tmux Plugin Manager owner : tmux-plugins repo : tpm command : link : - from : . to : $HOME/.tmux/plugins/tpm snippet : | echo \"tpm is installed, so tmux will be automatically launched\" echo \"see github.com/tmux-plugins/tpm\" if # Type Required string \"\" if allows you to specify the condition to load packages. If it returns true, then the command will be linked. But if it returns false, the command will not be linked. In if field, you can write shell scripts 1 . The exit code finally returned from that shell script is used to determine whether it links command or not. Case 1 link commands if git is installed github : - name : chmln/sd description : Intuitive find & replace CLI (sed alternative) owner : chmln repo : sd release : name : sd tag : 0.6.5 command : if : | type git &>/dev/null snippet : | replace() { case \"${#}\" in 1) git grep \"${1}\" ;; 2) git grep -l \"${1}\" | xargs -I% sd \"${1}\" \"${2}\" % ;; esac } link : - from : '**/sd' Shell used for an evaluation of if Defaults to bash . But you can change it with setting AFX_SHELL (or main.shell block on afx configuration) 2 e.g. export AFX_SHELL=zsh export AFX_SHELL=/bin/zsh You can configure your favorite shell to evaluate if field by setting AFX_SHELL . \u21a9 Not yet available. Coming soon. \u21a9","title":"Command"},{"location":"configuration/command/#command","text":"afx's goal is to finally support to install packages as command , plugin or both. In afx, several pacakge types (e.g. github ) are supported but you can specify command and plugin field in all of sources.","title":"Command"},{"location":"configuration/command/#parameters","text":"","title":"Parameters"},{"location":"configuration/command/#linkfrom","text":"Type Default string (required) link.from can be specified where to install from. Case 1 Case 2 Just install from current directory github : - name : so-fancy/diff-so-fancy description : Good-lookin' diffs. Actually\u2026 nah\u2026 The best-lookin' diffs. owner : so-fancy repo : diff-so-fancy command : link : - from : diff-so-fancy To specify where to install from, just need to fill in link.from . Case of including version string etc in file name github : - name : stedolan/jq description : Command-line JSON processor owner : stedolan repo : jq release : name : jq tag : jq-1.6 command : link : - from : '*jq*' to : jq This link.from field is based on downloaded package directory. If the binary name has unneeded string and it's difficult to find a binary with fixed string. In that case, you can use wildcard in from field.","title":"link.from"},{"location":"configuration/command/#linkto","text":"Type Default string $AFX_COMMAND_PATH/(command-name) link.to can be specified where to install to. If omitted, the command will be installed to $AFX_COMMAND_PATH . Case 1 Case 2 Case 3 Simple case, with renaming by using `to` field github : - name : mutantcornholio/prok description : easy process grep with ps output owner : mutantcornholio repo : prok command : link : - from : prok.sh to : prok By filling in link.to field, you can specify where to install to. This field can be omitted but in that case it will be regarded as same thing of link.from value. In short, you don't need to fill in this field if you don't need to rename link.from to new one while linking. If you want to rename command name from link.from to new one, you can use this field like above example (this prok.sh will be renamed to prok and then install it into PATH) from current working dir to external dir of afx github : - name : tmux-plugins/tpm description : Tmux Plugin Manager owner : tmux-plugins repo : tpm command : link : - from : . to : $HOME/.tmux/plugins/tpm This example shows you to link all contents in current working directory to ~/.tmux/plugins/tpm directory. You can use outside directory of afx in link.to field, but in that case you need to specify full path. Using tilda ~ is also ok to specify $HOME . Several links github : - name : ahmetb/kubectx description : Switch faster between clusters and namespaces in kubectl owner : ahmetb repo : kubectx command : link : - from : kubectx to : kubectl-ctx - from : kubens to : kubectl-ns link section is a list, so you can specify several pairs of from and to .","title":"link.to"},{"location":"configuration/command/#env","text":"Type Default map {} env allows you to set environment variables. By having this section in same YAML file of package declaration, you can manage it with same file. When we don't have afx, we should have environment variables in shell config (e.g. zshrc) even if not installed it yet or failed to install it. But thanks to afx, afx users can keep it with same files and enable it only while a package is installed. Needs to login new shell To enable environment variables to your shell, you need to run this command or start new shell after adding this command to your shel config (e.g. .zshrc): source < ( afx init ) Case 1 github : - name : sharkdp/bat description : A cat(1) clone with wings. owner : sharkdp repo : bat release : name : bat tag : v0.11.0 command : alias : bat-theme : bat --list-themes | fzf --preview='bat --theme={} --color=always ~/.zshrc' env : BAT_PAGER : less -RF BAT_STYLE : numbers,changes BAT_THEME : ansi-dark link : - from : '**/bat'","title":"env"},{"location":"configuration/command/#alias","text":"Type Default map {} alias allows you to set command aliases. Case 1 Case 2 Case 3 github : - name : daveewart/colordiff description : Primary development for colordiff owner : daveewart repo : colordiff command : alias : diff : colordiff -u link : - from : colordiff.pl to : colordiff github : - name : ogham/exa description : A modern version of 'ls'. owner : ogham repo : exa release : name : exa tag : v0.9.0 command : alias : l : exa --group-directories-first -T --git-ignore --level 2 la : exa --group-directories-first -a --header --git ll : exa --group-directories-first -l --header --git lla : exa --group-directories-first -la --header --git ls : exa --group-directories-first link : - from : '*exa*' to : exa github : - name : sharkdp/bat description : A cat(1) clone with wings. owner : sharkdp repo : bat release : name : bat tag : v0.11.0 command : alias : bat-theme : bat --list-themes | fzf --preview='bat --theme={} --color=always ~/.zshrc' env : BAT_PAGER : less -RF BAT_STYLE : numbers,changes BAT_THEME : ansi-dark link : - from : '**/bat'","title":"alias"},{"location":"configuration/command/#buildsteps","text":"Type Default list [] build.steps can be specified build commands to build a package. Case 1 Case 2 Using sudo github : - name : jhawthorn/fzy description : A better fuzzy finder owner : jhawthorn repo : fzy command : build : steps : - make - sudo make install In this case, build steps has sudo command but it can be run as expected. But in advance you will be asked to input sudo password. Using go build github : - name : iovisor/kubectl-trace description : Schedule bpftrace programs on your kubernetes cluster using the kubectl owner : iovisor repo : kubectl-trace command : build : steps : - go build -o kubectl-trace cmd/kubectl-trace/root.go link : - from : kubectl-trace to : kubectl-trace In this case, build steps run go build command because this package does not provide GitHub releases on its own page. So we need to build by ourselves. afx build feature is very helpful in such a case. go build command creates red command to current working directory so you need to have link section to install the built binary to your PATH.","title":"build.steps"},{"location":"configuration/command/#buildenv","text":"Type Required map {} build.env can be specified environemnt variables used when running build a package. Case 1 github : - name : jhawthorn/fzy description : A better fuzzy finder owner : jhawthorn repo : fzy command : build : steps : - make - sudo make install env : VERSION : 1.0 In this case, VERSION is specified to change version used in build steps.","title":"build.env"},{"location":"configuration/command/#snippet","text":"Type Required string \"\" snippet allows you to specify the command which are runned when starting new shell. Case 1 Login message if tpm is installed github : - name : tmux-plugins/tpm description : Tmux Plugin Manager owner : tmux-plugins repo : tpm command : link : - from : . to : $HOME/.tmux/plugins/tpm snippet : | echo \"tpm is installed, so tmux will be automatically launched\" echo \"see github.com/tmux-plugins/tpm\"","title":"snippet"},{"location":"configuration/command/#if","text":"Type Required string \"\" if allows you to specify the condition to load packages. If it returns true, then the command will be linked. But if it returns false, the command will not be linked. In if field, you can write shell scripts 1 . The exit code finally returned from that shell script is used to determine whether it links command or not. Case 1 link commands if git is installed github : - name : chmln/sd description : Intuitive find & replace CLI (sed alternative) owner : chmln repo : sd release : name : sd tag : 0.6.5 command : if : | type git &>/dev/null snippet : | replace() { case \"${#}\" in 1) git grep \"${1}\" ;; 2) git grep -l \"${1}\" | xargs -I% sd \"${1}\" \"${2}\" % ;; esac } link : - from : '**/sd' Shell used for an evaluation of if Defaults to bash . But you can change it with setting AFX_SHELL (or main.shell block on afx configuration) 2 e.g. export AFX_SHELL=zsh export AFX_SHELL=/bin/zsh You can configure your favorite shell to evaluate if field by setting AFX_SHELL . \u21a9 Not yet available. Coming soon. \u21a9","title":"if"},{"location":"configuration/plugin/","text":"Plugin # afx's goal is to finally support to install packages as command , plugin or both. In afx, several pacakge types (e.g. github ) are supported but you can specify command and plugin field in all of sources. Parameters # sources # Type Default list (required) sources allows you to select what to load files when starting shell. Case 1 Case 2 Case 3 Simple case, just register to init.sh as load scripts github : - name : b4b4r07/enhancd description : A next-generation cd command with your interactive filter owner : b4b4r07 repo : enhancd plugin : env : ENHANCD_FILTER : fzf --height 25% --reverse --ansi:fzy sources : - init.sh Using wildcards to register multiple files github : - name : b4b4r07/zsh-prompt-minimal description : Super super super minimal prompt for zsh owner : b4b4r07 repo : zsh-prompt-minimal plugin : env : PROMPT_PATH_STYLE : minimal PROMPT_USE_VIM_MODE : true sources : - '*.zsh-theme' Filenames starting with numbers local : - name : zsh directory : ~/.zsh plugin : sources : - '[0-9]*.zsh' env # Type Default map {} env allows you to set environment variables. By having this section in same YAML file of package declaration, you can manage it with same file. When we don't have afx, we should have environment variables in shell config (e.g. zshrc) even if not installed it yet or failed to install it. But thanks to afx, afx users can keep it with same files and enable it only while a package is installed. Needs to login new shell To enable environment variables to your shell, you need to run this command or start new shell after adding this command to your shel config (e.g. .zshrc): source < ( afx init ) Case 1 github : - name : b4b4r07/zsh-prompt-minimal description : Super super super minimal prompt for zsh owner : b4b4r07 repo : zsh-prompt-minimal plugin : env : PROMPT_PATH_STYLE : minimal PROMPT_USE_VIM_MODE : true sources : - '*.zsh-theme' snippet # Type Default string \"\" snippet allows you to specify the command which are runned when starting new shell. Case 1 Login message if tpm is installed github : - name : b4b4r07/enhancd description : A next-generation cd command with your interactive filter owner : b4b4r07 repo : enhancd plugin : env : ENHANCD_FILTER : fzf --height 25% --reverse --ansi:fzy sources : - init.sh snippet : | echo \"enhancd is enabled, cd command is overrided by enhancd\" echo \"see github.com/b4b4r07/enhancd\" snippet-prepare (beta) # Type Default string \"\" snippet-prepare allows you to specify the command which are runned when starting new shell. Unlike snippet , this snippet-prepare is run before source command. Run snippet-prepare Load sources Run snippet This option comes from #6 . Case 1 Run snippet before sources github : - name : sindresorhus/pure description : Pretty, minimal and fast ZSH prompt owner : sindresorhus repo : pure plugin : snippet-prepare : | zstyle :prompt:pure:git:branch color magenta zstyle :prompt:pure:git:branch:cached color yellow zstyle :prompt:pure:git:dirty color 091 zstyle :prompt:pure:user color blue zstyle :prompt:pure:host color blue sources : - pure.zsh if # Type Default string \"\" if allows you to specify the condition to load packages. If it returns true, then the plugin will be loaded. But if it returns false, the plugin will not be loaded. In if field, you can write shell scripts 1 . The exit code finally returned from that shell script is used to determine whether it loads plugin or not. Case 1 if login shell is zsh, plugin will be loaded local : - name : zsh directory : ~/.zsh plugin : if : | [[ $SHELL == *zsh* ]] sources : - '[0-9]*.zsh' You can configure your favorite shell to evaluate if field by setting AFX_SHELL . \u21a9","title":"Plugin"},{"location":"configuration/plugin/#plugin","text":"afx's goal is to finally support to install packages as command , plugin or both. In afx, several pacakge types (e.g. github ) are supported but you can specify command and plugin field in all of sources.","title":"Plugin"},{"location":"configuration/plugin/#parameters","text":"","title":"Parameters"},{"location":"configuration/plugin/#sources","text":"Type Default list (required) sources allows you to select what to load files when starting shell. Case 1 Case 2 Case 3 Simple case, just register to init.sh as load scripts github : - name : b4b4r07/enhancd description : A next-generation cd command with your interactive filter owner : b4b4r07 repo : enhancd plugin : env : ENHANCD_FILTER : fzf --height 25% --reverse --ansi:fzy sources : - init.sh Using wildcards to register multiple files github : - name : b4b4r07/zsh-prompt-minimal description : Super super super minimal prompt for zsh owner : b4b4r07 repo : zsh-prompt-minimal plugin : env : PROMPT_PATH_STYLE : minimal PROMPT_USE_VIM_MODE : true sources : - '*.zsh-theme' Filenames starting with numbers local : - name : zsh directory : ~/.zsh plugin : sources : - '[0-9]*.zsh'","title":"sources"},{"location":"configuration/plugin/#env","text":"Type Default map {} env allows you to set environment variables. By having this section in same YAML file of package declaration, you can manage it with same file. When we don't have afx, we should have environment variables in shell config (e.g. zshrc) even if not installed it yet or failed to install it. But thanks to afx, afx users can keep it with same files and enable it only while a package is installed. Needs to login new shell To enable environment variables to your shell, you need to run this command or start new shell after adding this command to your shel config (e.g. .zshrc): source < ( afx init ) Case 1 github : - name : b4b4r07/zsh-prompt-minimal description : Super super super minimal prompt for zsh owner : b4b4r07 repo : zsh-prompt-minimal plugin : env : PROMPT_PATH_STYLE : minimal PROMPT_USE_VIM_MODE : true sources : - '*.zsh-theme'","title":"env"},{"location":"configuration/plugin/#snippet","text":"Type Default string \"\" snippet allows you to specify the command which are runned when starting new shell. Case 1 Login message if tpm is installed github : - name : b4b4r07/enhancd description : A next-generation cd command with your interactive filter owner : b4b4r07 repo : enhancd plugin : env : ENHANCD_FILTER : fzf --height 25% --reverse --ansi:fzy sources : - init.sh snippet : | echo \"enhancd is enabled, cd command is overrided by enhancd\" echo \"see github.com/b4b4r07/enhancd\"","title":"snippet"},{"location":"configuration/plugin/#snippet-prepare-beta","text":"Type Default string \"\" snippet-prepare allows you to specify the command which are runned when starting new shell. Unlike snippet , this snippet-prepare is run before source command. Run snippet-prepare Load sources Run snippet This option comes from #6 . Case 1 Run snippet before sources github : - name : sindresorhus/pure description : Pretty, minimal and fast ZSH prompt owner : sindresorhus repo : pure plugin : snippet-prepare : | zstyle :prompt:pure:git:branch color magenta zstyle :prompt:pure:git:branch:cached color yellow zstyle :prompt:pure:git:dirty color 091 zstyle :prompt:pure:user color blue zstyle :prompt:pure:host color blue sources : - pure.zsh","title":"snippet-prepare (beta)"},{"location":"configuration/plugin/#if","text":"Type Default string \"\" if allows you to specify the condition to load packages. If it returns true, then the plugin will be loaded. But if it returns false, the plugin will not be loaded. In if field, you can write shell scripts 1 . The exit code finally returned from that shell script is used to determine whether it loads plugin or not. Case 1 if login shell is zsh, plugin will be loaded local : - name : zsh directory : ~/.zsh plugin : if : | [[ $SHELL == *zsh* ]] sources : - '[0-9]*.zsh' You can configure your favorite shell to evaluate if field by setting AFX_SHELL . \u21a9","title":"if"},{"location":"configuration/package/gist/","text":"Gist # Gist type allows you to manage Gist pages as a plugin or command. gist : - name : context-scripts description : Get current GCP/Kubernetes context which you are on. owner : b4b4r07 id : bb820b99fdba605ea4bd4fb29046ce58 command : link : - from : gcp-context - from : kube-context Parameters # name # Type Default string (required) Package name. Name it as you like. In Gist, there's a case that several files are attached in one Gist. So may be better to name considering it. description # Type Default string \"\" Package description. owner # Type Default string (required) Gist owner. id # Type Default string (required) Gist page id. depends-on # See GitHub#depends-on page. Same as that. command # See Command page plugin # See Plugin page","title":"Gist"},{"location":"configuration/package/gist/#gist","text":"Gist type allows you to manage Gist pages as a plugin or command. gist : - name : context-scripts description : Get current GCP/Kubernetes context which you are on. owner : b4b4r07 id : bb820b99fdba605ea4bd4fb29046ce58 command : link : - from : gcp-context - from : kube-context","title":"Gist"},{"location":"configuration/package/gist/#parameters","text":"","title":"Parameters"},{"location":"configuration/package/gist/#name","text":"Type Default string (required) Package name. Name it as you like. In Gist, there's a case that several files are attached in one Gist. So may be better to name considering it.","title":"name"},{"location":"configuration/package/gist/#description","text":"Type Default string \"\" Package description.","title":"description"},{"location":"configuration/package/gist/#owner","text":"Type Default string (required) Gist owner.","title":"owner"},{"location":"configuration/package/gist/#id","text":"Type Default string (required) Gist page id.","title":"id"},{"location":"configuration/package/gist/#depends-on","text":"See GitHub#depends-on page. Same as that.","title":"depends-on"},{"location":"configuration/package/gist/#command","text":"See Command page","title":"command"},{"location":"configuration/package/gist/#plugin","text":"See Plugin page","title":"plugin"},{"location":"configuration/package/github/","text":"GitHub # GitHub type allows you to get GitHub repository or GitHub Release. To get releases, you need to specify release field. In GitHub type, there are mainly two type of package style. One is a \"repository\" and the other is \"release\". In afx configuration, a release field is optional so basically all of GitHub packages are regard as \"repository\". It's a same reason why actual GitHub Release pages exists on its GitHub Repository. But if release field is specified, in afx, it's regard as also \"release\". It may be good to think about whether to configure release field depending on where you install it from. Repository Release github : - name : ahmetb/kubectx description : Switch faster between clusters and namespaces in kubectl owner : ahmetb repo : kubectx command : link : - from : kubectx to : kubectl-ctx - from : kubens to : kubectl-ns github : - name : stedolan/jq description : Command-line JSON processor owner : stedolan repo : jq release : name : jq tag : jq-1.6 command : link : - from : '*jq*' to : jq Parameters # name # Type Default string (required) Package name. Basically you can name it as you like. However, in GitHub package, \"owner/repo\" style may be suitable. description # Type Default string \"\" Package description. owner # Type Default string (required) Repository owner. repo # Type Default string (required) Repository name. branch # Type Default string master Remote branch name. with.depth # Type Default number 0 (all commits) Limit fetching to the specified number of commits from the tip of each remote branch history. If fetching to a shallow repository, specify 1 or more number, deepen or shorten the history to the specified number of commits. release.name # Type Default string \"\" Allows you to specify a package name managed in GitHub Release. You can find this by visiting release page of packages you want to install. relase.tag # Type Default string \"\" Allows you to specify a tag version of GitHub Release. You can find this by visiting release page of packages you want to install. release.asset.filename # Type Default string \"\" Allows you to specify a filename of GitHub Release asset you want to install. Moreover, this field in afx config file supports templating. (Basically) NO NEED TO SET THIS Basically in afx, it's no problem even if you don't specify this field when downloading a package from GitHub Release. Because afx automatically filters release assets that can work on your system (OS/Architecture, etc) even if several release assets are uploaded. But the filename of the package uploaded to GitHub Release can be named by its author freely. So there are cases that afx cannot filter the package which is suitable on your system when too much special wording is included in a filename. For example, the following case is, a filename has \"steve-jobs\" instead of \"mac\" or \"darwin\": some-package-v1.0.0-steve-jobs-amd64.tar.gz Case 1 Case 2 Specify asset filename directly github : - name : direnv/direnv description : Unclutter your .profile owner : direnv repo : direnv release : name : direnv tag : v2.30.3 asset : filename : direnv.darwin-amd64 command : link : - from : direnv Specify asset filename with templating github : - name : direnv/direnv description : Unclutter your .profile owner : direnv repo : direnv release : name : direnv tag : v2.30.3 asset : filename : '{{ .Release.Name }}.{{ .OS }}-{{ .Arch }}' command : link : - from : direnv You can specify a filename from asset list on GitHub Release page. It allows to specify a filename directly and also to use name templating feature by using these variables provided by afx: Key Description .Release.Name Same as release.name .Release.Tag Same as release.tag .OS GOOS 1 (e.g. darwin etc) .Arch GOARCH 1 (e.g. amd64 etc) release.asset.replacements # Type Default map {} Allows you to replace pre-defined OS/Architecture wording with yours. In afx, the templating variables of .OS and .Arch are coming from runtime.GOOS and runtime.GOARCH (The Go Programming Language). For example, your system is Mac: In this case, GOOS returns darwin string, but let's say the filename of the assets on GitHub Release you want has mac instead of darwin . In this case, you can replace it with darwin by defining this replacements map. asset : filename : '{{ .Release.Name }}-{{ .Release.Tag }}-{{ .Arch }}-{{ .OS }}.tar.gz' replacements : darwin : mac Keys should be valid GOOS s or GOARCH s. Valid name is below (full is are on Environment - The Go Programming Language ). Values are the respective replacements. GOOS GOARCH darwin amd64 darwin arm64 linux 386 linux amd64 linux arm64 windows 386 windows amd64 windows arm64 Case 1 github : - name : sharkdp/bat description : A cat(1) clone with wings. owner : sharkdp repo : bat release : name : bat tag : v0.11.0 asset : filename : '{{ .Release.Name }}-{{ .Release.Tag }}-{{ .Arch }}-{{ .OS }}.tar.gz' replacements : darwin : apple-darwin amd64 : x86_64 command : link : - from : '**/bat' Due to specifying release.asset.filename field, you can choose what you install explicitly. It's not only but also you can replace these .OS and .Arch with what you like. Above example will be templated from: '{{ .Release.Name }}-{{ .Release.Tag }}-{{ .Arch }}-{{ .OS }}.tar.gz' to: bat-v0.11.0-x86_64-apple-darwin.tar.gz depends-on # Type Default list [] Allows you to specify dependency list between packages to handle hidden dependency that afx can't automatically infer. Explicitly specifying a dependency is helpful when a package relies on some other package's behavior. Concretely it's good for handling the order of loading files listed on plugin.sources when running afx init . Let's say you want to manage pkg-a and pkg-b with afx. Also let's say pkg-a needs to be loaded after pkg-b (This means pkg-a depends on pkg-b ). In this case you can specify dependencies: Case 1 local : - name : zsh directory : ~/.zsh plugin : if : | [[ $SHELL == *zsh* ]] sources : - '[0-9]*.zsh' depends-on : - google-cloud-sdk - name : google-cloud-sdk directory : ~/Downloads/google-cloud-sdk plugin : env : PATH : ~/Downloads/google-cloud-sdk/bin sources : - '*.zsh.inc' Thanks to depends-on , the order of loading sources are: * zsh -> google-cloud-sdk Let's see the actual output with afx init in case we added depends-on like above config: $ afx init ... source /Users/babarot/Downloads/google-cloud-sdk/completion.zsh.inc source /Users/babarot/Downloads/google-cloud-sdk/path.zsh.inc export PATH=\"$PATH:/Users/babarot/Downloads/google-cloud-sdk/bin\" ... source /Users/babarot/.zsh/10_utils.zsh source /Users/babarot/.zsh/20_keybinds.zsh source /Users/babarot/.zsh/30_aliases.zsh source /Users/babarot/.zsh/50_setopt.zsh source /Users/babarot/.zsh/70_misc.zsh ... ... command # See Command page plugin # See Plugin page This can be overwritten by replace.asset.replacements . \u21a9 \u21a9","title":"GitHub"},{"location":"configuration/package/github/#github","text":"GitHub type allows you to get GitHub repository or GitHub Release. To get releases, you need to specify release field. In GitHub type, there are mainly two type of package style. One is a \"repository\" and the other is \"release\". In afx configuration, a release field is optional so basically all of GitHub packages are regard as \"repository\". It's a same reason why actual GitHub Release pages exists on its GitHub Repository. But if release field is specified, in afx, it's regard as also \"release\". It may be good to think about whether to configure release field depending on where you install it from. Repository Release github : - name : ahmetb/kubectx description : Switch faster between clusters and namespaces in kubectl owner : ahmetb repo : kubectx command : link : - from : kubectx to : kubectl-ctx - from : kubens to : kubectl-ns github : - name : stedolan/jq description : Command-line JSON processor owner : stedolan repo : jq release : name : jq tag : jq-1.6 command : link : - from : '*jq*' to : jq","title":"GitHub"},{"location":"configuration/package/github/#parameters","text":"","title":"Parameters"},{"location":"configuration/package/github/#name","text":"Type Default string (required) Package name. Basically you can name it as you like. However, in GitHub package, \"owner/repo\" style may be suitable.","title":"name"},{"location":"configuration/package/github/#description","text":"Type Default string \"\" Package description.","title":"description"},{"location":"configuration/package/github/#owner","text":"Type Default string (required) Repository owner.","title":"owner"},{"location":"configuration/package/github/#repo","text":"Type Default string (required) Repository name.","title":"repo"},{"location":"configuration/package/github/#branch","text":"Type Default string master Remote branch name.","title":"branch"},{"location":"configuration/package/github/#withdepth","text":"Type Default number 0 (all commits) Limit fetching to the specified number of commits from the tip of each remote branch history. If fetching to a shallow repository, specify 1 or more number, deepen or shorten the history to the specified number of commits.","title":"with.depth"},{"location":"configuration/package/github/#releasename","text":"Type Default string \"\" Allows you to specify a package name managed in GitHub Release. You can find this by visiting release page of packages you want to install.","title":"release.name"},{"location":"configuration/package/github/#relasetag","text":"Type Default string \"\" Allows you to specify a tag version of GitHub Release. You can find this by visiting release page of packages you want to install.","title":"relase.tag"},{"location":"configuration/package/github/#releaseassetfilename","text":"Type Default string \"\" Allows you to specify a filename of GitHub Release asset you want to install. Moreover, this field in afx config file supports templating. (Basically) NO NEED TO SET THIS Basically in afx, it's no problem even if you don't specify this field when downloading a package from GitHub Release. Because afx automatically filters release assets that can work on your system (OS/Architecture, etc) even if several release assets are uploaded. But the filename of the package uploaded to GitHub Release can be named by its author freely. So there are cases that afx cannot filter the package which is suitable on your system when too much special wording is included in a filename. For example, the following case is, a filename has \"steve-jobs\" instead of \"mac\" or \"darwin\": some-package-v1.0.0-steve-jobs-amd64.tar.gz Case 1 Case 2 Specify asset filename directly github : - name : direnv/direnv description : Unclutter your .profile owner : direnv repo : direnv release : name : direnv tag : v2.30.3 asset : filename : direnv.darwin-amd64 command : link : - from : direnv Specify asset filename with templating github : - name : direnv/direnv description : Unclutter your .profile owner : direnv repo : direnv release : name : direnv tag : v2.30.3 asset : filename : '{{ .Release.Name }}.{{ .OS }}-{{ .Arch }}' command : link : - from : direnv You can specify a filename from asset list on GitHub Release page. It allows to specify a filename directly and also to use name templating feature by using these variables provided by afx: Key Description .Release.Name Same as release.name .Release.Tag Same as release.tag .OS GOOS 1 (e.g. darwin etc) .Arch GOARCH 1 (e.g. amd64 etc)","title":"release.asset.filename"},{"location":"configuration/package/github/#releaseassetreplacements","text":"Type Default map {} Allows you to replace pre-defined OS/Architecture wording with yours. In afx, the templating variables of .OS and .Arch are coming from runtime.GOOS and runtime.GOARCH (The Go Programming Language). For example, your system is Mac: In this case, GOOS returns darwin string, but let's say the filename of the assets on GitHub Release you want has mac instead of darwin . In this case, you can replace it with darwin by defining this replacements map. asset : filename : '{{ .Release.Name }}-{{ .Release.Tag }}-{{ .Arch }}-{{ .OS }}.tar.gz' replacements : darwin : mac Keys should be valid GOOS s or GOARCH s. Valid name is below (full is are on Environment - The Go Programming Language ). Values are the respective replacements. GOOS GOARCH darwin amd64 darwin arm64 linux 386 linux amd64 linux arm64 windows 386 windows amd64 windows arm64 Case 1 github : - name : sharkdp/bat description : A cat(1) clone with wings. owner : sharkdp repo : bat release : name : bat tag : v0.11.0 asset : filename : '{{ .Release.Name }}-{{ .Release.Tag }}-{{ .Arch }}-{{ .OS }}.tar.gz' replacements : darwin : apple-darwin amd64 : x86_64 command : link : - from : '**/bat' Due to specifying release.asset.filename field, you can choose what you install explicitly. It's not only but also you can replace these .OS and .Arch with what you like. Above example will be templated from: '{{ .Release.Name }}-{{ .Release.Tag }}-{{ .Arch }}-{{ .OS }}.tar.gz' to: bat-v0.11.0-x86_64-apple-darwin.tar.gz","title":"release.asset.replacements"},{"location":"configuration/package/github/#depends-on","text":"Type Default list [] Allows you to specify dependency list between packages to handle hidden dependency that afx can't automatically infer. Explicitly specifying a dependency is helpful when a package relies on some other package's behavior. Concretely it's good for handling the order of loading files listed on plugin.sources when running afx init . Let's say you want to manage pkg-a and pkg-b with afx. Also let's say pkg-a needs to be loaded after pkg-b (This means pkg-a depends on pkg-b ). In this case you can specify dependencies: Case 1 local : - name : zsh directory : ~/.zsh plugin : if : | [[ $SHELL == *zsh* ]] sources : - '[0-9]*.zsh' depends-on : - google-cloud-sdk - name : google-cloud-sdk directory : ~/Downloads/google-cloud-sdk plugin : env : PATH : ~/Downloads/google-cloud-sdk/bin sources : - '*.zsh.inc' Thanks to depends-on , the order of loading sources are: * zsh -> google-cloud-sdk Let's see the actual output with afx init in case we added depends-on like above config: $ afx init ... source /Users/babarot/Downloads/google-cloud-sdk/completion.zsh.inc source /Users/babarot/Downloads/google-cloud-sdk/path.zsh.inc export PATH=\"$PATH:/Users/babarot/Downloads/google-cloud-sdk/bin\" ... source /Users/babarot/.zsh/10_utils.zsh source /Users/babarot/.zsh/20_keybinds.zsh source /Users/babarot/.zsh/30_aliases.zsh source /Users/babarot/.zsh/50_setopt.zsh source /Users/babarot/.zsh/70_misc.zsh ... ...","title":"depends-on"},{"location":"configuration/package/github/#command","text":"See Command page","title":"command"},{"location":"configuration/package/github/#plugin","text":"See Plugin page This can be overwritten by replace.asset.replacements . \u21a9 \u21a9","title":"plugin"},{"location":"configuration/package/http/","text":"HTTP # HTTP type allows you to manage a plugin or command hosted on any websites except for a source code hosting site such as GitHub etc. http : - name : gcping description : Like gcping.com but a command line tool url : https://storage.googleapis.com/gcping-release/gcping_darwin_arm64_latest command : link : - from : gcping_* to : gcping Parameters # name # Type Default string (required) Package name. description # Type Default string \"\" Package description. url # Type Default string (required) Specify a URL that a command or plugin you want to install are hosted. In this field, you can use template variables: Case 1 http : - name : gcping description : Like gcping.com but a command line tool url : 'https://storage.googleapis.com/gcping-release/{{ .Name }}_{{ .OS }}_{{ .Arch }}_latest' templates : replacements : darwin : darwin # can replace \"darwin\" as you like! command : link : - from : gcping_* to : gcping Key Description .Name Same as .name (Package name) .OS GOOS 1 (e.g. darwin etc) .Arch GOARCH 1 (e.g. amd64 etc) templates.replacements # Type Default list [] In .url field, the template variables can be used. Also you can replace it with your own values. For more details, see also below page. See GitHub#release.asset.replacements depends-on # See GitHub#depends-on page. Same as that. command # See Command page plugin # See Plugin page This can be overwritten by templates.replacements . \u21a9 \u21a9","title":"HTTP"},{"location":"configuration/package/http/#http","text":"HTTP type allows you to manage a plugin or command hosted on any websites except for a source code hosting site such as GitHub etc. http : - name : gcping description : Like gcping.com but a command line tool url : https://storage.googleapis.com/gcping-release/gcping_darwin_arm64_latest command : link : - from : gcping_* to : gcping","title":"HTTP"},{"location":"configuration/package/http/#parameters","text":"","title":"Parameters"},{"location":"configuration/package/http/#name","text":"Type Default string (required) Package name.","title":"name"},{"location":"configuration/package/http/#description","text":"Type Default string \"\" Package description.","title":"description"},{"location":"configuration/package/http/#url","text":"Type Default string (required) Specify a URL that a command or plugin you want to install are hosted. In this field, you can use template variables: Case 1 http : - name : gcping description : Like gcping.com but a command line tool url : 'https://storage.googleapis.com/gcping-release/{{ .Name }}_{{ .OS }}_{{ .Arch }}_latest' templates : replacements : darwin : darwin # can replace \"darwin\" as you like! command : link : - from : gcping_* to : gcping Key Description .Name Same as .name (Package name) .OS GOOS 1 (e.g. darwin etc) .Arch GOARCH 1 (e.g. amd64 etc)","title":"url"},{"location":"configuration/package/http/#templatesreplacements","text":"Type Default list [] In .url field, the template variables can be used. Also you can replace it with your own values. For more details, see also below page. See GitHub#release.asset.replacements","title":"templates.replacements"},{"location":"configuration/package/http/#depends-on","text":"See GitHub#depends-on page. Same as that.","title":"depends-on"},{"location":"configuration/package/http/#command","text":"See Command page","title":"command"},{"location":"configuration/package/http/#plugin","text":"See Plugin page This can be overwritten by templates.replacements . \u21a9 \u21a9","title":"plugin"},{"location":"configuration/package/local/","text":"Local # Local type allows you to manage a plugin or command located locally in your system. You can also just run source command on your rc files (e.g. zshrc) to load your settings divided into other shell scripts without using this Local type. But by using this package type, you can manage them as same like other packages on afx ecosystem. local : - name : zsh description : My zsh scripts directory : ~/.zsh plugin : sources : - '[0-9]*.zsh' - name : google-cloud-sdk description : Google Cloud SDK directory : ~/Downloads/google-cloud-sdk plugin : sources : - '*.zsh.inc' Parameters # name # Type Default string (required) Package name. description # Type Default string \"\" Package description. directory # Type Default string (required) Specify a directory path that files you want to load are put. Allow to use ~ (tilda) and environment variables (e.g. $HOME ) here. Of course, specifying full path is also acceptable. depends-on # See GitHub#depends-on page. Same as that. command # See Command page plugin # See Plugin page","title":"Local"},{"location":"configuration/package/local/#local","text":"Local type allows you to manage a plugin or command located locally in your system. You can also just run source command on your rc files (e.g. zshrc) to load your settings divided into other shell scripts without using this Local type. But by using this package type, you can manage them as same like other packages on afx ecosystem. local : - name : zsh description : My zsh scripts directory : ~/.zsh plugin : sources : - '[0-9]*.zsh' - name : google-cloud-sdk description : Google Cloud SDK directory : ~/Downloads/google-cloud-sdk plugin : sources : - '*.zsh.inc'","title":"Local"},{"location":"configuration/package/local/#parameters","text":"","title":"Parameters"},{"location":"configuration/package/local/#name","text":"Type Default string (required) Package name.","title":"name"},{"location":"configuration/package/local/#description","text":"Type Default string \"\" Package description.","title":"description"},{"location":"configuration/package/local/#directory","text":"Type Default string (required) Specify a directory path that files you want to load are put. Allow to use ~ (tilda) and environment variables (e.g. $HOME ) here. Of course, specifying full path is also acceptable.","title":"directory"},{"location":"configuration/package/local/#depends-on","text":"See GitHub#depends-on page. Same as that.","title":"depends-on"},{"location":"configuration/package/local/#command","text":"See Command page","title":"command"},{"location":"configuration/package/local/#plugin","text":"See Plugin page","title":"plugin"}]}